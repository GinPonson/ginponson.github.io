<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="1、线程和进程的区别？线程是系统调度的基本单位，进程是系统分配资源的基本单位。进程可以包含多个线程，这些线程是共同享有进程占有的资源和地址空间的a. 一个程序至少有一个进程，一个进程至少有一个线程；b. 线程的划分尺度小于进程，使得多线程程序的并发性高；c. 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率；d. 每个独立的线程有一个程序运行的入口、顺序执行序">
<meta property="og:type" content="article">
<meta property="og:title" content="知识点回顾-多线程篇">
<meta property="og:url" content="http://yoursite.com/2017/01/30/review-thread/index.html">
<meta property="og:site_name" content="ln -s to memory">
<meta property="og:description" content="1、线程和进程的区别？线程是系统调度的基本单位，进程是系统分配资源的基本单位。进程可以包含多个线程，这些线程是共同享有进程占有的资源和地址空间的a. 一个程序至少有一个进程，一个进程至少有一个线程；b. 线程的划分尺度小于进程，使得多线程程序的并发性高；c. 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率；d. 每个独立的线程有一个程序运行的入口、顺序执行序">
<meta property="og:image" content="http://images.cnitblog.com/blog/288799/201409/061046391107893.jpg">
<meta property="og:updated_time" content="2017-03-06T14:53:55.339Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="知识点回顾-多线程篇">
<meta name="twitter:description" content="1、线程和进程的区别？线程是系统调度的基本单位，进程是系统分配资源的基本单位。进程可以包含多个线程，这些线程是共同享有进程占有的资源和地址空间的a. 一个程序至少有一个进程，一个进程至少有一个线程；b. 线程的划分尺度小于进程，使得多线程程序的并发性高；c. 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率；d. 每个独立的线程有一个程序运行的入口、顺序执行序">
<meta name="twitter:image" content="http://images.cnitblog.com/blog/288799/201409/061046391107893.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"display":"hide","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/01/30/review-thread/"/>





  <title> 知识点回顾-多线程篇 | ln -s to memory </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  

  <div class="container one-collumn  page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ln -s to memory</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">停停走走，回头看看</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/30/review-thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="GinPonson">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/10008744?v=3&s=460">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ln -s to memory">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                知识点回顾-多线程篇
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-30T20:23:33+08:00">
                2017-01-30
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/01/30/review-thread/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/30/review-thread/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>1、线程和进程的区别？<br>线程是系统调度的基本单位，进程是系统分配资源的基本单位。<br>进程可以包含多个线程，这些线程是共同享有进程占有的资源和地址空间的<br>a. 一个程序至少有一个进程，一个进程至少有一个线程；<br>b. 线程的划分尺度小于进程，使得多线程程序的并发性高；<br>c. 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率；<br>d. 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制；<br>e. 多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。<br><a id="more"></a><br>2、线程的生命周期？<br><img src="http://images.cnitblog.com/blog/288799/201409/061046391107893.jpg" alt="线程的生命周期"><br>3、线程的实现方法？<br>实现Runnable 或者继承Thread，使用start启动</p>
<p>4、yield、join、wait、sleep、notify、notifyAll<br>Thread.yield：法会让当前线程交出CPU权限，让CPU去执行其他的线程，不释放锁，线程进入就绪状态<br>thread.join：等待线程执行完毕，内部使用wait方法实现，会让线程进入阻塞状态，并且会释放线程占有的锁，并交出CPU执行权限<br>Thread.sleep：相当于让线程睡眠，交出CPU，让CPU去执行其他的任务。sleep方法不会释放锁，线程进入阻塞状态。<br>object.wait：能让当前线程阻塞，并且当前线程必须拥有此对象的monitor。让当前线程交出此对象的monitor，然后进入等待状态，等待后续再次获得此对象的锁。<br>object.notify：能够唤醒一个正在等待这个对象的monitor的线程，如果有多个线程都在等待这个对象的monitor，则只能唤醒其中一个线程，并不是立即获得锁<br>object.notifyAll：能够唤醒所有正在等待这个对象的monitor的线程，然后系统分配所给哪个线程</p>
<p>5、synchronized和lock的区别？<br>a.当一个线程正在访问一个对象的synchronized方法，那么其他线程不能访问该对象的其他synchronized方法。这个原因很简单，因为一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized方法。</p>
<p>b.当一个线程正在访问一个对象的synchronized方法，那么其他线程能访问该对象的非synchronized方法。这个原因很简单，访问非synchronized方法不需要获得该对象的锁，假如一个方法没用synchronized关键字修饰，说明它不会使用到临界资源，那么其他线程是可以访问这个方法的，</p>
<p>c.如果一个线程A需要访问对象object1的synchronized方法fun1，另外一个线程B需要访问对象object2的synchronized方法fun1，即使object1和object2是同一类型），也不会产生线程安全问题，因为他们访问的是不同的对象，所以不存在互斥问题。</p>
<p>d.synchronized代码块实际上多了monitorenter和monitorexit两条指令,对于synchronized方法，执行中的线程识别该方法的 method_info 结构是否有 ACC_SYNCHRONIZED 标记设置，然后它自动获取对象的锁，调用方法，最后释放锁</p>
<p>c.对于synchronized方法或者synchronized代码块，当出现异常时，JVM会自动释放当前线程占用的锁，因此不会由于异常导致出现死锁现象。</p>
<p>1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</p>
<p>2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</p>
<p>3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</p>
<p>4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</p>
<p>5）Lock可以提高多个线程进行读操作的效率。</p>
<p>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p>
<p>6、volatile关键字的作用<br>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>
<p>2）禁止进行指令重排序。</p>
<p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p>
<p>底层原理<br>　　lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p>
<p>1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p>
<p>2）它会强制将对缓存的修改操作立即写入主存；</p>
<p>3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>
<p>使用场景（状态标记量）<br>1）对变量的写操作不依赖于当前值</p>
<p>2）该变量没有包含在具有其他变量的不变式中</p>
<p>7、并发编程的3个概念<br>原子性问题，可见性问题，有序性问题</p>
<p>8、同步容器？<br>容器的非线程安全问题<br>缺陷：<br>效率低、<br>并非真正安全：循环操作不是原子操作，之锁定对应的方法<br>ConcurrentModificationException</p>
<p>9、ConcurrentModificationException？<br>单线程使用Iterator，然后却不使用Iterator的remove，使全局modCount和Iterator的expectedModCount不一致。<br>解决：只使用Iterator的remove，remove(index)和remove(item)非Iterator中使用<br>多线程中多个线程修改modCoount，导致不一致。<br>解决：加锁、并发容器</p>
<p>10、ConcurrentHashMap？<br>ConcurrentHashMap为了提高本身的并发能力，在内部采用了一个叫做Segment的结构，一个Segment其实就是一个类Hash Table的结构，Segment内部维护了一个链表数组。ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作，第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部，因此，这一种结构的带来的副作用是Hash的过程要比普通的HashMap要长，但是带来的好处是写操作的时候可以只对元素所在的Segment进行加锁即可，不会影响到其他的Segment，这样，在最理想的情况下，ConcurrentHashMap可以最高同时支持Segment数量大小的写操作（刚好这些写操作都非常平均地分布在所有的Segment上），所以，通过这一种结构，ConcurrentHashMap的并发能力可以大大的提高。<br>get不用加锁，如果取出的value为null，则加锁<br>put、remove加锁，remove后，后面的元素会复制到前面，HashEntry next final<br>size，对比modCount是否相同，如果不同，再重复一次后，加锁Segment</p>
<p>11、CopyOnWrite容器？<br>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器<br>内存占用问题、数据一致性问题。</p>
<p>12、阻塞队列？</p>
<table><br>    <tr><br>        <td>add满了报错 </td><br>        <td>remove空报错</td><br>    </tr><br>    <tr><br>        <td>offer满了false </td><br>        <td>poll空false</td><br>    </tr><br>    <tr><br>        <td>put阻塞</td><br>        <td>peek获取first，不移除</td><br>    </tr><br>    <tr><br>        <td></td><br>        <td>take阻塞</td><br>    </tr><br></table>

<p>13、线程池<br>1）首先，要清楚corePoolSize和maximumPoolSize的含义；</p>
<p>2）其次，要知道Worker是用来起到什么作用的；<br>负责处理任务<br>3）要知道任务提交给线程池之后的处理策略，这里总结一下主要有4点：</p>
<p>如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；<br>如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；<br>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；<br>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。</p>
<p>14、CountDownLatch、CyclicBarrier和Semaphore<br>1）CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：</p>
<p>CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；</p>
<p>而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；</p>
<p>另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。</p>
<p>2）Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。</p>
<p>15、读写锁<br>读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。</p>
<p>正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。<br>提升了读操作的效率。</p>
<p>不过要注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。</p>
<p>如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/01/29/review-knowledge/" rel="next" title="知识点回顾-Java篇">
                <i class="fa fa-chevron-left"></i> 知识点回顾-Java篇
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/01/31/review-java-web/" rel="prev" title="知识点回顾-Web篇">
                知识点回顾-Web篇 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/01/30/review-thread/"
           data-title="知识点回顾-多线程篇" data-url="http://yoursite.com/2017/01/30/review-thread/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars0.githubusercontent.com/u/10008744?v=3&s=460"
               alt="GinPonson" />
          <p class="site-author-name" itemprop="name">GinPonson</p>
           
              <p class="site-description motion-element" itemprop="description">爱搞事情，事情克星</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/GinPonson" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/2815235385?wvr=4&lf=reg" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">GinPonson</span>
</div>



        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"ginponson"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  

  

  

  

  


  

</body>
</html>
