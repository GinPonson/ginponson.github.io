[{"title":"spring websocket浏览器连接时出现404错误","date":"2017-02-09T13:51:42.000Z","path":"2017/02/09/spring-websocket-404/","text":"在用websocket做一个简单的数据导入页面同步显示后台进度功能的时候，浏览器出现连接不上的错误：WebSocket connection to &#39;ws://localhost:8080/project/marco&#39; failed: Error during WebSocket handshake: Unexpected response code: 404 网上有很种导致404的情况，但是都没有用，我在这里记录一下我的情况。以下是我的解决过程，要看解决办法的请直接到最后。spring-websocket.xml12345678&lt;websocket:handlers&gt;&lt;websocket:mapping handler=\"messageHandler\" path=\"/marco\" /&gt;&lt;websocket:handshake-interceptors&gt; &lt;bean class=\"com.project.websocket.HandshakeInterceptor\"/&gt;&lt;/websocket:handshake-interceptors&gt;&lt;/websocket:handlers&gt;&lt;bean id=\"messageHandler\" class=\"com.project.websocket.MessageHandler\"/&gt; 查看打印的INFO级别日志，根据spring的启动信息我们可以看到：12017-02-09 21:57:40,559 INFO [springframework.web.servlet.handler.SimpleUrlHandlerMapping] - Mapped URL path [/marco] onto handler of type [class org.springframework.web.socket.server.support.WebSocketHttpRequestHandler] WebSocketHttpRequestHandler通过SimpleUrlHandlerMapping注册了/marco地址，那应该是没错的啊，难道是客户端js的错误？1var websocket = new WebSocket('ws://' + window.location.host + '/project/marco'); 地址好像也没错啊，和Spring in Action4里面的例子一样的啊。为什么地址没有映射到/marco？先看看DispatchServlet的handlerMappings有没有/marco先吧。断点DispatchServlet的doDispatch()方法，随便发起一个请求：12345678910protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ...... // Determine handler for the current request. mappedHandler = getHandler(processedRequest); if (mappedHandler == null || mappedHandler.getHandler() == null) &#123; noHandlerFound(processedRequest, response); return; &#125; ......&#125; 进入getHandler(processedRequest)12345678910111213protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; for (HandlerMapping hm : this.handlerMappings) &#123; if (logger.isTraceEnabled()) &#123; logger.trace( \"Testing handler map [\" + hm + \"] in DispatcherServlet with name '\" + getServletName() + \"'\"); &#125; HandlerExecutionChain handler = hm.getHandler(request); if (handler != null) &#123; return handler; &#125; &#125; return null;&#125; 我们看一下handlerMappings里面的内容，不知道你们有没有找到/marco，反正我是没找到。言下之意，/marco没注册到？ 没办法，我们断点SimpleUrlHandlerMapping的registerHandlers()方法和DispatchServlet的initHandlerMappings()方法。 我们看到SimpleUrlHandlerMapping的registerHandlers()先被执行。 最后退出registerHandlers()方法，F6一路下来，从WebApplicationObjectSupport的initApplicationContext()方法中可以看到： context.beanFactory.beanDefintionMap中包含[org.springframework.web.servlet.handler.SimpleUrlHandlerMapping#0-&gt;RootBeanDefintion] 而且context.beanFactory.singletonObjects也包含了注册了/marco的SimpleUrlHandlerMapping实例。 此时的context.configLocations是classpath:spring-context.xml。 DispatchServlet的initHandlerMappings()后被执行，我们来看这段：123// Find all HandlerMappings in the ApplicationContext, including ancestor contexts.Map&lt;String, HandlerMapping&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false); 然而，在matchingBeans没有找到我们要的注册了/marco的SimpleUrlHandlerMapping。此时的context.configLocations是classpath*:spring-servlet.xml 来到这里，你大概知道就是你的spring-websocket.xml放错位置啦。 解决办法如果你的web.xml分开加载spring-context和spring-servlet的话，请将spring-websocket的资源文件放到spring-servlet上加载。注意：在spring-context加载的时候，你的messageHandler应该是还没有初始化，请不要注入到某个server上。","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"},{"name":"websocket","slug":"websocket","permalink":"http://yoursite.com/tags/websocket/"}]},{"title":"知识点回顾-Jvm篇","date":"2017-02-05T07:17:45.000Z","path":"2017/02/05/review-jvm/","text":"","tags":[]},{"title":"知识点回顾-其他篇","date":"2017-02-02T13:24:14.000Z","path":"2017/02/02/review-others/","text":"复习完上面的一系列知识点，现在来复习一些剩余的知识点。这一篇复习redis，linux，这些知识点都是重要内功心法。 1、redis 什么是redis？redis能干什么？和M相比怎么样？ redis有哪些基本类型？ 如何用GET和SET实现INCR命令？ 怎么实现事务？redis的事务有什么特点？ redis如何实现缓存？ SORT命令有什么用？BY？GET？STORE？ redis怎么实现阻塞的任务队列？ redis怎么实现发布者-订阅者模型？ redis怎么优化？ redis持久化的方式？ 2、MySql MySQL有几种引擎？ MySQL如何主从同步？ MySQL有几种索引类型？有几种索引方法？ MySQL和Redis有什么不同？ 什么是关系型数据库？ MySQL是行级锁还是表级锁？","tags":[{"name":"面试复习","slug":"面试复习","permalink":"http://yoursite.com/tags/面试复习/"}]},{"title":"知识点回顾-框架篇","date":"2017-02-01T12:20:50.000Z","path":"2017/02/01/review-framework/","text":"上一篇回顾完web的知识点,这篇来回顾常见的框架。Java的框架有很多，有很多也是造轮子，所以在恰当的场景使用恰当的轮子也是一件重要的事。 1、Spring全家桶 什么是spring？使用spring有什么好处？ 什么是IOC？为什么要用IOC？ 什么是AOP？ 关于Spring的69个面试问答——终极列表Spring面试问答Top 25Spring面试问题集锦Spring常见面试问题 2、Struts2 Struts2是什么？ 3、hibernate hibernate的理解？ N+1的解决办法？ hibernate的几种状态？ list和iterate不同之处 一级缓存和二级缓存和査询缓存 缓存算法？ 什么是事务？spring事务的传播方式？事务的隔离级别？ 事务并发处理 4、mybatis mybatis与hibernate相比怎么样？ 3、spring mvc 和struts21、Struts2是类级别的拦截， 一个类对应一个request上下文，SpringMVC是方法级别的拦截，一个方法对应一个request上下文，而方法同时又跟一个url对应,所以说从架构本身上SpringMVC就容易实现restful url,而struts2的架构实现起来要费劲，因为Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了。 2、由上边原因，SpringMVC的方法之间基本上独立的，独享request response数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架，方法之间不共享变量，而Struts2搞的就比较乱，虽然方法之间也是独立的，但其所有Action变量是共享的，这不会影响程序运行，却给我们编码 读程序时带来麻烦，每次来了请求就创建一个Action，一个Action对象对应一个request上下文。3、由于Struts2需要针对每个request进行封装，把request，session等servlet生命周期的变量封装成一个一个Map，供给每个Action使用，并保证线程安全，所以在原则上，是比较耗费内存的。 4、拦截器实现机制上，Struts2有以自己的interceptor机制，SpringMVC用的是独立的AOP方式，这样导致Struts2的配置文件量还是比SpringMVC大。 5、SpringMVC的入口是servlet，而Struts2是filter（这里要指出，filter和servlet是不同的。以前认为filter是servlet的一种特殊），这就导致了二者的机制不同，这里就牵涉到servlet和filter的区别了。 6、SpringMVC集成了Ajax，使用非常方便，只需一个注解@ResponseBody就可以实现，然后直接返回响应文本即可，而Struts2拦截器集成了Ajax，在Action中处理时一般必须安装插件或者自己写代码集成进去，使用起来也相对不方便。 7、SpringMVC验证支持JSR303，处理起来相对更加灵活方便，而Struts2验证比较繁琐，感觉太烦乱。 8、Spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高（当然Struts2也可以通过不同的目录结构和相关配置做到SpringMVC一样的效果，但是需要xml配置的地方不少）。 9、 设计思想上，Struts2更加符合OOP的编程思想， SpringMVC就比较谨慎，在servlet上扩展。 10、SpringMVC开发效率和性能高于Struts2。","tags":[{"name":"面试复习","slug":"面试复习","permalink":"http://yoursite.com/tags/面试复习/"}]},{"title":"知识点回顾-Web篇","date":"2017-01-31T05:37:11.000Z","path":"2017/01/31/review-java-web/","text":"上一篇回顾完java，这篇来回顾web的知识点。 1、TCP/IP协议 &amp;&amp; http协议 OSI七层模型？ TCP和UDP的特点？ 简单说一下TCP三次握手？ TCP的拥塞控制，和滑动窗口机制？ http协议有什么特点？ 浏览器请求到服务器响应的过程？ http和https的区别？ http的GET和POST方法有什么区别？ 什么是restful编程？ http的状态码？ 2、cookie &amp;&amp; session cookie和session有什么作用？ cookie是什么？session又是什么？ cookie和session有什么区别？ 3、servlet &amp;&amp; JSP servlet的生命周期？ servlet的原理？ servlet和JSP的关系？ dispatch和forward？ 什么时候调用doGet(),doPost()？ request.getAttribute()和request.getParamater()区别？ JSP的内置对象？ JSP的基本动作？ JSP动态include和静态include的区别？ 4、filter filter和servlet有什么区别？ filter的原理？ filter涉及的设计模式？ 1、servlet和filter的区别？ 1、servlet可以产生一个请求或者响应，filter只能修改对某一资源的请求，或者修改从某一的响应2、生命周期：servlet：如果有load on startup，那么容器初始化的时候会按照值从小到大加载。当一个请求映射到对应的地址后，如果容器没有加载servlet，则加载servlet。Servlet容器创建一个Servlet实例并且调用Servlet的init()方法进行初始化，调用init()。根据method由doservice分配到doGet或者doPost服务器停止后销毁。 filter:容器初始化的时候初始化。服务器停止后销毁，晚于Servlet销毁之后 5、服务器5.1、nginx 什么是nginx？nginx和Apache相比怎么样？ nginx能干什么？ nginx的基本操作命令？ nginx怎么设置代理服务器？ 正向代理和反向代理的区别？ 5.2、tomcat URL乱码？ Tomcat启动oom？ tomcat的优化经验？","tags":[{"name":"面试复习","slug":"面试复习","permalink":"http://yoursite.com/tags/面试复习/"}]},{"title":"知识点回顾-多线程篇","date":"2017-01-30T12:23:33.000Z","path":"2017/01/30/review-thread/","text":"1、线程和进程的区别？线程是系统调度的基本单位，进程是系统分配资源的基本单位。进程可以包含多个线程，这些线程是共同享有进程占有的资源和地址空间的a. 一个程序至少有一个进程，一个进程至少有一个线程；b. 线程的划分尺度小于进程，使得多线程程序的并发性高；c. 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率；d. 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制；e. 多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。2、线程的生命周期？3、线程的实现方法？实现Runnable 或者继承Thread，使用start启动 4、yield、join、wait、sleep、notify、notifyAllThread.yield：法会让当前线程交出CPU权限，让CPU去执行其他的线程，不释放锁，线程进入就绪状态thread.join：等待线程执行完毕，内部使用wait方法实现，会让线程进入阻塞状态，并且会释放线程占有的锁，并交出CPU执行权限Thread.sleep：相当于让线程睡眠，交出CPU，让CPU去执行其他的任务。sleep方法不会释放锁，线程进入阻塞状态。object.wait：能让当前线程阻塞，并且当前线程必须拥有此对象的monitor。让当前线程交出此对象的monitor，然后进入等待状态，等待后续再次获得此对象的锁。object.notify：能够唤醒一个正在等待这个对象的monitor的线程，如果有多个线程都在等待这个对象的monitor，则只能唤醒其中一个线程，并不是立即获得锁object.notifyAll：能够唤醒所有正在等待这个对象的monitor的线程，然后系统分配所给哪个线程 5、synchronized和lock的区别？a.当一个线程正在访问一个对象的synchronized方法，那么其他线程不能访问该对象的其他synchronized方法。这个原因很简单，因为一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized方法。 b.当一个线程正在访问一个对象的synchronized方法，那么其他线程能访问该对象的非synchronized方法。这个原因很简单，访问非synchronized方法不需要获得该对象的锁，假如一个方法没用synchronized关键字修饰，说明它不会使用到临界资源，那么其他线程是可以访问这个方法的， c.如果一个线程A需要访问对象object1的synchronized方法fun1，另外一个线程B需要访问对象object2的synchronized方法fun1，即使object1和object2是同一类型），也不会产生线程安全问题，因为他们访问的是不同的对象，所以不存在互斥问题。 d.synchronized代码块实际上多了monitorenter和monitorexit两条指令,对于synchronized方法，执行中的线程识别该方法的 method_info 结构是否有 ACC_SYNCHRONIZED 标记设置，然后它自动获取对象的锁，调用方法，最后释放锁 c.对于synchronized方法或者synchronized代码块，当出现异常时，JVM会自动释放当前线程占用的锁，因此不会由于异常导致出现死锁现象。 1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现； 2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁； 3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断； 4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。 5）Lock可以提高多个线程进行读操作的效率。 在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。 6、volatile关键字的作用1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 2）禁止进行指令重排序。 “观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令” 底层原理 lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能： 1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成； 2）它会强制将对缓存的修改操作立即写入主存； 3）如果是写操作，它会导致其他CPU中对应的缓存行无效。 使用场景（状态标记量）1）对变量的写操作不依赖于当前值 2）该变量没有包含在具有其他变量的不变式中 7、并发编程的3个概念原子性问题，可见性问题，有序性问题 8、同步容器？容器的非线程安全问题缺陷：效率低、并非真正安全：循环操作不是原子操作，之锁定对应的方法ConcurrentModificationException 9、ConcurrentModificationException？单线程使用Iterator，然后却不使用Iterator的remove，使全局modCount和Iterator的expectedModCount不一致。解决：只使用Iterator的remove，remove(index)和remove(item)非Iterator中使用多线程中多个线程修改modCoount，导致不一致。解决：加锁、并发容器 10、ConcurrentHashMap？ConcurrentHashMap为了提高本身的并发能力，在内部采用了一个叫做Segment的结构，一个Segment其实就是一个类Hash Table的结构，Segment内部维护了一个链表数组。ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作，第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部，因此，这一种结构的带来的副作用是Hash的过程要比普通的HashMap要长，但是带来的好处是写操作的时候可以只对元素所在的Segment进行加锁即可，不会影响到其他的Segment，这样，在最理想的情况下，ConcurrentHashMap可以最高同时支持Segment数量大小的写操作（刚好这些写操作都非常平均地分布在所有的Segment上），所以，通过这一种结构，ConcurrentHashMap的并发能力可以大大的提高。get不用加锁，如果取出的value为null，则加锁put、remove加锁，remove后，后面的元素会复制到前面，HashEntry next finalsize，对比modCount是否相同，如果不同，再重复一次后，加锁Segment 11、CopyOnWrite容器？CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器内存占用问题、数据一致性问题。 12、阻塞队列？ add满了报错 remove空报错 offer满了false poll空false put阻塞 peek获取first，不移除 take阻塞 13、线程池1）首先，要清楚corePoolSize和maximumPoolSize的含义； 2）其次，要知道Worker是用来起到什么作用的；负责处理任务3）要知道任务提交给线程池之后的处理策略，这里总结一下主要有4点： 如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。 14、CountDownLatch、CyclicBarrier和Semaphore1）CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同： CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行； 而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行； 另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。 2）Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。 15、读写锁读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。 正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。提升了读操作的效率。 不过要注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。 如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。","tags":[]},{"title":"知识点回顾-Java篇","date":"2017-01-29T01:42:15.000Z","path":"2017/01/29/review-knowledge/","text":"面临跳槽季，面试都是各种套路，为了避免被套路，根据自己会的知识点列出一张脑图来，脑补到时候考官会根据对应的知识点逐步细问。 将各个知识点切割开来，逐个细分，首先是编程语言的各个知识点 Java 什么是面向对象，面向对象的特征？ Java的多态机制？ 重载和重写有什么区别？ 1、java.lang String、StringBuilder和StringBuffer的区别？ String的内部结构-&gt;substring的实现-&gt;1.7以前substring内存泄漏？ 为什么String被设计为final类？(final字段的作用) intern()的作用？ “==”和equals有什么区别？ Class.forName作用，和static加载的区别？ 基本类型的封装对象的缓存机制 浮点数的计算问题 clone()? 2、java.io io使用的设计模式中的哪个模式？-&gt;作用？ 3、Collection &amp;&amp; Map Collection涉及的设计模式？-&gt;作用？ List和Set的区别？ 3.1、List、Stack、Queue Vector和ArrayList的区别？ ArrayList和LinkedList的实现？ Stack的特点？Queue的特点？ Java ConcurrentModificationException异常原因和解决方法？ 3.2、Set和Map 什么是哈希冲突？java是怎么解决哈希冲突的？ Comparable和Comparator有什么区别？ 有序set集合应该使用哪个？需要做什么？ java.lang.Object的equals()和hashCode()？ Hashtable和HashMap的区别？ 4、异常 受检异常和运行异常有什么不同？ Error和Exception有什么不同？ 异常的处理机制？ try{}catch{}finally{}的执行顺序？ 各举5个常见的异常 5、线程 &amp;&amp; java.util.concorrent 多线程的实现方法？ 同步的方法有哪些？它们之间有什么区别？ sleep和wait有什么区别？ ThreadLocal的作用？ Thread的生命周期？ 生产者和消费者模型？ ConcurrentHashMap和HashMap和Hashtable的区别？ 怎么实现一个线程池？ 阻塞队列？ 6、java.sql 操作数据库读取数据的过程？ 7、java.rmi 远程代理？","tags":[{"name":"面试复习","slug":"面试复习","permalink":"http://yoursite.com/tags/面试复习/"}]}]