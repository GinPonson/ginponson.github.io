[{"title":"开始种罗勒","date":"2017-04-18T13:28:38.000Z","path":"2017/04/18/plant-basil-diary/","text":"前些日子逛超市，居然发现有杯装的盆栽买，当然了，里面只有土和种子，并不是那种已经长大的植株。里面有几个品种，什么番茄、波斯菊、罗勒都有，而我选的是罗勒，对罗勒并不是很了解，但是莫名的想买的这个。种这些小盆栽其实挺有趣，自己亲手播种，看着小苗一天天的长大，感觉自己又好像找到了一个生活寄托。这几天快要离职了，当初一毕业的时候就在公司工作，一眨眼间就已经过去了两年了。想想当初也是碰得满头包，很是感激老大给了我这个机会，感激现在和我一起工作的江老师:)虽然辞职了，但是生活还是要继续，收拾好心情，继续上路。","tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"},{"name":"种花","slug":"种花","permalink":"http://yoursite.com/tags/种花/"}]},{"title":"Selenium/HtmlUnit设置代理获取JS生成的网页","date":"2017-04-08T02:04:21.000Z","path":"2017/04/08/Selenium-HtmlUnit-get-js-render-page/","text":"通常我们使用Java提供的HttpURLConnection或者Apache的HttpClient获取的网页源代码都是直观可见的，其代码的内容和通过浏览器右键网页-&gt;点击查看网页源代码的内容一致。 但是现在越来越多的网站使用Js来动态生成内容来提高相应速度，而HttpClient只是返回后端相应的response的请求主体，并没有返回浏览器生成的网页，所以对于Js生成的内容HttpClient是获取不了的。 对于获取Js生成的网页，我们主要通过模拟浏览器的运行，渲染response的请求主体最终得到对应的内容，得到的内容和通过浏览器右键网页-&gt;点击检查/查看元素的内容一致。 我们这里讲的模拟方法大概有两种： 一种是使用Selenium 一种是使用HtmlUnit 抓取目标我们这次的目标是获取bilibili动态生成的动画列表，左上是抓取的目标列表，左下是浏览器渲染的html内容，右面是服务器返回的response的正文。通过对比，我们可以看出目标列表是Js生成。 使用Selenium获取页面Selenium是一个用于Web应用自动化测试的工具，更多的介绍就谷歌。这里我们主要用作模拟页面的运行并将结果返回，对于网页截图的功能也是可行的。 Selenium支持模拟很多浏览器，但是我们这里只模拟PhantomJS，因为PhantomJS 是一个脚本化的无界面 WebKit，以 JavaScript 为脚本语言实现各项功能。由于是无界面的，所以速度性能方面会较好。 1.下载使用PhantomJS需要到官网下载最新的客户端，这里使用phantomjs-2.1.1-windows.zip 2.maven依赖引入：1234567891011121314151617181920&lt;dependency&gt; &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt; &lt;artifactId&gt;selenium-java&lt;/artifactId&gt; &lt;version&gt;2.53.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.codeborne&lt;/groupId&gt; &lt;artifactId&gt;phantomjsdriver&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt; &lt;artifactId&gt;selenium-remote-driver&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt; &lt;artifactId&gt;selenium-java&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 3.示例代码1234567891011121314151617181920212223242526272829303132333435import org.openqa.selenium.WebDriver;import org.openqa.selenium.phantomjs.PhantomJSDriver;import org.openqa.selenium.phantomjs.PhantomJSDriverService;import org.openqa.selenium.remote.DesiredCapabilities;import java.util.ArrayList;/** * @author GinPonson */public class TestSelenium &#123; static final String HOST = \"127.0.0.1\"; static final String PORT = \"80\"; static final String USER = \"gin\"; static final String PWD = \"12345\"; public static void main(String[] args)&#123; System.setProperty(\"phantomjs.binary.path\", \"D:\\\\phantomjs-2.1.1-windows\\\\bin\\\\phantomjs.exe\"); DesiredCapabilities capabilities = DesiredCapabilities.phantomjs(); //设置代理或者其他参数 ArrayList&lt;String&gt; cliArgsCap = new ArrayList&lt;&gt;(); //cliArgsCap.add(\"--proxy=http://\"+HOST+\":\"+PORT); //cliArgsCap.add(\"--proxy-auth=\" + USER + \":\" + PWD); //cliArgsCap.add(\"--proxy-type=http\"); capabilities.setCapability(PhantomJSDriverService.PHANTOMJS_CLI_ARGS, cliArgsCap); //capabilities.setCapability(\"phantomjs.page.settings.userAgent\", \"\"); WebDriver driver = new PhantomJSDriver(capabilities); driver.get(\"http://www.bilibili.com/video/bangumi-two-1.html\"); System.out.println(driver.getPageSource()); driver.quit(); &#125;&#125; 4.其他功能 设置参数或者代理：去掉上面的注释，就可以使用自己的代理了。 操作页面，返回操作后页面内容：不多说了，这里介绍一下可以做。 页面截图：返回浏览器的全屏截图。 使用HtmlUnit获取页面HtmlUnit功能上算是是Selenium的一个子集，Selenium有对应的HtmlUnit实现。HtmlUnit是用Java写的无界面的浏览器，正因为其没有界面,因此执行的速度还是可以的。 1.maven依赖引入12345&lt;dependency&gt; &lt;groupId&gt;net.sourceforge.htmlunit&lt;/groupId&gt; &lt;artifactId&gt;htmlunit&lt;/artifactId&gt; &lt;version&gt;2.25&lt;/version&gt;&lt;/dependency&gt; 2.Java代码12345678910111213141516171819202122232425262728/** * @author GinPonson */public class TestHtmlUnit &#123; static final String HOST = \"127.0.0.1\"; static final String PORT = \"80\"; static final String USER = \"gin\"; static final String PWD = \"12345\"; public static void main(String[] args) throws Exception&#123; WebClient webClient = new WebClient(); //设置代理 //ProxyConfig proxyConfig = webClient.getOptions().getProxyConfig(); //proxyConfig.setProxyHost(HOST); //proxyConfig.setProxyPort(Integer.valueOf(PORT)); //DefaultCredentialsProvider credentialsProvider = (DefaultCredentialsProvider) webClient.getCredentialsProvider(); //credentialsProvider.addCredentials(USER, PWD); //设置参数 //webClient.getOptions().setCssEnabled(false); //webClient.getOptions().setJavaScriptEnabled(false); webClient.getOptions().setThrowExceptionOnScriptError(false); HtmlPage page = webClient.getPage(\"http://www.bilibili.com/video/bangumi-two-1.html\"); System.out.println(page.asXml()); webClient.close(); &#125;&#125; 3.其他功能 设置参数或者代理：去掉上面的注释，就可以使用自己的代理了。 操作页面，返回操作后页面内容：不多说了，这里介绍一下可以做。 解析页面 总结PhantomJS和HtmlUnit模拟浏览器页面的生成功能都不错，PhantomJS作为一个无界面的WebKit，渲染页面的功能非常完善，而且带有浏览器截图功能，能模拟登录操作。HtmlUnit使用Rhino引擎来解析Js，有时候解析速度非常慢，就像上面的例子，费了很长时间，但是HtmlUnit可以获取页面，解析元素一套做完(当然解析元素还是使用Jsoup好)，是不错的工具。HtmlUnit遇到错误后，前后处理相差7分钟，可能是我不会用QAQ欢迎补充:)","tags":[{"name":"Selenium","slug":"Selenium","permalink":"http://yoursite.com/tags/Selenium/"},{"name":"HtmlUnit","slug":"HtmlUnit","permalink":"http://yoursite.com/tags/HtmlUnit/"}]},{"title":"spring websocket浏览器连接时出现404错误","date":"2017-02-09T13:51:42.000Z","path":"2017/02/09/spring-websocket-404/","text":"在用websocket做一个简单的数据导入页面同步显示后台进度功能的时候，浏览器出现404的错误。 1WebSocket connection to 'ws://localhost:8080/project/marco' failed: Error during WebSocket handshake: Unexpected response code: 404 网上有很种导致404的情况，但是都没有用，我在这里记录一下我的情况。spring-websocket.xml12345678&lt;websocket:handlers&gt;&lt;websocket:mapping handler=\"messageHandler\" path=\"/marco\" /&gt;&lt;websocket:handshake-interceptors&gt; &lt;bean class=\"com.project.websocket.HandshakeInterceptor\"/&gt;&lt;/websocket:handshake-interceptors&gt;&lt;/websocket:handlers&gt;&lt;bean id=\"messageHandler\" class=\"com.project.websocket.MessageHandler\"/&gt; 查看打印的INFO级别日志，根据spring的启动信息我们可以看到：12017-02-09 21:57:40,559 INFO [springframework.web.servlet.handler.SimpleUrlHandlerMapping] - Mapped URL path [/marco] onto handler of type [class org.springframework.web.socket.server.support.WebSocketHttpRequestHandler] WebSocketHttpRequestHandler通过SimpleUrlHandlerMapping注册了/marco地址，那应该是没错的啊，难道是客户端js的错误？1var websocket = new WebSocket('ws://' + window.location.host + '/project/marco'); 地址好像也没错啊，和Spring in Action4里面的例子一样的啊。为什么地址没有映射到/marco？先看看DispatchServlet的handlerMappings有没有/marco先吧。断点DispatchServlet的doDispatch()方法，随便发起一个请求：12345678910protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ...... // Determine handler for the current request. mappedHandler = getHandler(processedRequest); if (mappedHandler == null || mappedHandler.getHandler() == null) &#123; noHandlerFound(processedRequest, response); return; &#125; ......&#125; 进入getHandler(processedRequest)12345678910111213protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; for (HandlerMapping hm : this.handlerMappings) &#123; if (logger.isTraceEnabled()) &#123; logger.trace( \"Testing handler map [\" + hm + \"] in DispatcherServlet with name '\" + getServletName() + \"'\"); &#125; HandlerExecutionChain handler = hm.getHandler(request); if (handler != null) &#123; return handler; &#125; &#125; return null;&#125; 我们看一下handlerMappings里面的内容，不知道你们有没有找到/marco，反正我是没找到。言下之意，/marco没注册到？没办法，我们断点SimpleUrlHandlerMapping的registerHandlers()方法和DispatchServlet的initHandlerMappings()方法。我们看到SimpleUrlHandlerMapping的registerHandlers()先被执行。最后退出registerHandlers()方法，F6一路下来，从WebApplicationObjectSupport的initApplicationContext()方法中可以看到： [org.springframework.web.servlet.handler.SimpleUrlHandlerMapping#0-&gt;RootBeanDefintion]包含在context.beanFactory.beanDefintionMap中 而且context.beanFactory.singletonObjects也包含了注册了/marco的SimpleUrlHandlerMapping实例。 此时的context.configLocations是classpath:spring-context.xml。 DispatchServlet的initHandlerMappings()后被执行，我们来看这段：123// Find all HandlerMappings in the ApplicationContext, including ancestor contexts.Map&lt;String, HandlerMapping&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false); 然而，在matchingBeans没有找到我们要的注册了/marco的SimpleUrlHandlerMapping。此时的context.configLocations是classpath*:spring-servlet.xml 来到这里，你大概知道就是你的spring-websocket.xml放错位置啦。 解决办法如果你的web.xml分开加载spring-context和spring-servlet的话，请将spring-websocket的资源文件放到spring-servlet上加载。注意：在spring-context加载的时候，你的messageHandler应该是还没有初始化，请不要注入到某个service上。","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"},{"name":"websocket","slug":"websocket","permalink":"http://yoursite.com/tags/websocket/"}]}]